var V="offline-data-manager",Z=1,L=null,i={REGISTRY:"registry",DOWNLOAD_QUEUE:"downloadQueue"};async function J(e,t){V=e??"offline-data-manager",Z=t??1}async function T(){return L||(L=await new Promise((e,t)=>{let r=indexedDB.open(V,Z);r.onupgradeneeded=a=>{let n=a.target.result;if(!n.objectStoreNames.contains(i.REGISTRY)){let o=n.createObjectStore(i.REGISTRY,{keyPath:"id"});o.createIndex("protected","protected",{unique:!1}),o.createIndex("priority","priority",{unique:!1})}if(!n.objectStoreNames.contains(i.DOWNLOAD_QUEUE)){let o=n.createObjectStore(i.DOWNLOAD_QUEUE,{keyPath:"id"});o.createIndex("status","status",{unique:!1}),o.createIndex("priority","priority",{unique:!1})}},r.onsuccess=()=>e(r.result),r.onerror=()=>t(r.error)}),L)}async function p(e,t){let r=await T();return new Promise((a,n)=>{let o=r.transaction(e,"readonly").objectStore(e).get(t);o.onsuccess=()=>a(o.result),o.onerror=()=>n(o.error)})}async function g(e){let t=await T();return new Promise((r,a)=>{let n=t.transaction(e,"readonly").objectStore(e).getAll();n.onsuccess=()=>r(n.result),n.onerror=()=>a(n.error)})}async function N(e){let t=await T();return new Promise((r,a)=>{let n=t.transaction(e,"readonly").objectStore(e).getAllKeys();n.onsuccess=()=>r(n.result),n.onerror=()=>a(n.error)})}async function y(e,t){let r=await T();return new Promise((a,n)=>{let o=r.transaction(e,"readwrite").objectStore(e).put(t);o.onsuccess=()=>a(),o.onerror=()=>n(o.error),o.onerror=()=>n(o.error)})}async function S(e,t){let r=await T();return new Promise((a,n)=>{let o=r.transaction(e,"readwrite").objectStore(e).delete(t);o.onsuccess=()=>a(),o.onerror=()=>n(o.error)})}var U=new Map;function q(e,t){return U.has(e)||U.set(e,new Set),U.get(e).add(t),()=>P(e,t)}function P(e,t){U.get(e)?.delete(t)}function u(e,t){U.get(e)?.forEach(r=>{try{r(t)}catch(a){console.error(`[offline-data-manager] Error in "${e}" listener:`,a)}})}function ee(e,t){let r=a=>{t(a),P(e,r)};q(e,r)}async function I(){if(!navigator?.storage?.estimate)return{usage:0,quota:1/0,available:1/0};let{usage:e=0,quota:t=1/0}=await navigator.storage.estimate();return{usage:e,quota:t,available:t-e}}async function te(e){let{available:t,quota:r}=await I();return t-r*.1>=e}async function re(){return navigator?.storage?.persist?navigator.storage.persist():!1}async function oe(){return navigator?.storage?.persisted?navigator.storage.persisted():!1}function M(e){return e===1/0?"\u221E":e<1024?`${e} B`:e<1024**2?`${(e/1024).toFixed(1)} KB`:e<1024**3?`${(e/1024**2).toFixed(1)} MB`:`${(e/1024**3).toFixed(2)} GB`}var G=null,B=null,v=!1,W=!0;function ne(){u("connectivity",{online:!1}),G?.()}function ae(){u("connectivity",{online:!0}),B?.()}function ie({pauseAll:e,resumeAll:t}){v||(G=e,B=t,window&&(window.addEventListener("offline",ne),window.addEventListener("online",ae)),v=!0)}function $(){globalThis.window&&(window.removeEventListener("offline",ne),window.removeEventListener("online",ae)),G=null,B=null,v=!1}function _(){return globalThis.window?navigator.onLine??!0:W}function Y(){return v}function se(e){W=e,v&&(W?B?.():G?.())}var Oe=2*1024*1024,xe=5*1024*1024,Te=2,le=5,Ue=1e3,E=new Map,b=!1,C=null;function ue(){return new Promise(e=>{C=e})}function h(){if(C){let e=C;C=null,e()}}var Ie=e=>new Promise(t=>setTimeout(t,e)),ve=e=>Ue*Math.pow(2,e);async function m(e,t){let r=await p(i.DOWNLOAD_QUEUE,e);r&&await y(i.DOWNLOAD_QUEUE,{...r,...t})}async function _e(e,t){try{let r=await fetch(e,{method:"HEAD",signal:t}),a=r.headers.get("Accept-Ranges")==="bytes",n=r.headers.get("Content-Encoding"),o=!!n&&n!=="identity",s=r.headers.get("Content-Length"),l=s&&!o?parseInt(s,10):null,c=de(r.headers.get("Content-Type"));return{supportsRange:a,totalBytes:l,mimeType:c}}catch{return{supportsRange:!1,totalBytes:null,mimeType:null}}}function de(e){return e&&e.split(";")[0].trim()||null}function ce(e){let t=e.reduce((n,o)=>n+o.byteLength,0),r=new Uint8Array(t),a=0;for(let n of e)r.set(n,a),a+=n.byteLength;return r}async function Le(e){let{id:t,downloadUrl:r,ttl:a}=e,n=new AbortController;E.set(t,n);let o=await p(i.DOWNLOAD_QUEUE,t),s=o?.retryCount??0;for(;s<=le;)try{await m(t,{status:d.IN_PROGRESS,lastAttemptAt:Date.now(),retryCount:s,errorMessage:null}),u("status",{id:t,status:d.IN_PROGRESS}),o=await p(i.DOWNLOAD_QUEUE,t);let l=o?.byteOffset??0,c=!1,f=o?.totalBytes??e.totalBytes??null,w=e.mimeType??null;if(l===0){let R=await _e(r,n.signal);c=R.supportsRange,R.totalBytes&&(f=R.totalBytes,await m(t,{totalBytes:f})),!w&&R.mimeType&&(w=R.mimeType)}else c=!0;let D=c&&f&&f>xe,A,x=null;if(D)A=await Pe(t,r,l,f,n.signal);else{let R=await Ne(t,r,n.signal);A=R.uint8,x=R.mimeType}let K=w??x??"application/octet-stream",F=A.buffer,z=Date.now(),he=ye(z,a);await m(t,{status:d.COMPLETE,data:F,mimeType:K,bytesDownloaded:F.byteLength,byteOffset:F.byteLength,completedAt:z,expiresAt:he,errorMessage:null,deferredReason:null}),u("complete",{id:t,mimeType:K}),E.delete(t);return}catch(l){if(l?.name==="QuotaExceededError"){await k(),await m(t,{status:d.DEFERRED,deferredReason:"insufficient-storage"}),u("error",{id:t,reason:"insufficient-storage",willRetry:!1});return}else if(l?.name==="AbortError"){await m(t,{status:d.PAUSED}),u("status",{id:t,status:d.PAUSED}),E.delete(t);return}if(s++,s>le){await m(t,{status:d.FAILED,retryCount:s,errorMessage:l.message}),u("error",{id:t,error:l,retryCount:s}),E.delete(t);return}let c=ve(s-1);console.warn(`[offline-data-manager] "${t}" failed (attempt ${s}), retrying in ${c}ms:`,l.message),u("error",{id:t,error:l,retryCount:s,willRetry:!0}),await m(t,{status:d.PENDING,retryCount:s,errorMessage:l.message}),await Ie(c)}}async function Ne(e,t,r){let a=await fetch(t,{signal:r});if(!a.ok)throw new Error(`HTTP ${a.status} ${a.statusText}`);let n=a.headers.get("Content-Encoding"),o=!!n&&n!=="identity",s=a.headers.get("Content-Length"),l=s&&!o?parseInt(s,10):null,c=de(a.headers.get("Content-Type")),f=a.body.getReader(),w=[],D=0;for(;;){let{done:A,value:x}=await f.read();if(A)break;w.push(x),D+=x.byteLength,await m(e,{bytesDownloaded:D,totalBytes:l}),u("progress",{id:e,bytesDownloaded:D,totalBytes:l,percent:l?Math.round(D/l*100):null})}return{uint8:ce(w),mimeType:c}}async function Pe(e,t,r,a,n){let o=r,s=[],l=r;for(;o<a;){let c=Math.min(o+Oe-1,a-1),f=await fetch(t,{signal:n,headers:{Range:`bytes=${o}-${c}`}});if(!f.ok&&f.status!==206)throw new Error(`HTTP ${f.status} on Range bytes=${o}-${c}`);let w=new Uint8Array(await f.arrayBuffer());s.push(w),o+=w.byteLength,l+=w.byteLength,await m(e,{bytesDownloaded:l,byteOffset:o}),u("progress",{id:e,bytesDownloaded:l,totalBytes:a,percent:Math.round(l/a*100)})}return ce(s)}async function Me(e){await ge();let[t,r]=await Promise.all([g(i.REGISTRY),g(i.DOWNLOAD_QUEUE)]),a=new Map(t.map(l=>[l.id,l])),n=r.filter(l=>[d.PENDING,d.IN_PROGRESS,d.PAUSED,d.DEFERRED,d.EXPIRED].includes(l.status)).sort((l,c)=>(a.get(l.id)?.priority??10)-(a.get(c.id)?.priority??10));if(n.length===0)return;let o=[...n],s=new Set;await new Promise(l=>{function c(){if(!b){l();return}if(o.length===0){s.size===0&&l();return}if(s.size>=e)return;let f=o.shift(),w=a.get(f.id);if(!w){c();return}let D=(async()=>{let A=w.totalBytes??f.totalBytes??0;if(A>0&&!await te(A)){await m(f.id,{status:d.DEFERRED,deferredReason:"insufficient-storage"}),u("deferred",{id:f.id,reason:"insufficient-storage"});return}await Le(w)})().finally(()=>{s.delete(D),c()});s.add(D),c()}c()})}function fe({concurrency:e=Te}={}){b||(b=!0,(async()=>{for(;b;){if(!_()){let t=await g(i.DOWNLOAD_QUEUE);for(let r of t)r.status===d.IN_PROGRESS&&(E.get(r.id)?.abort(),E.delete(r.id),await m(r.id,{status:d.PAUSED,deferredReason:"network-offline"}));u("connectivity",{online:!1}),await ue();continue}await Me(e),b&&await ue()}})())}async function k(){b=!1,h(),await O(),u("stopped",{})}async function pe(){let e=await g(i.DOWNLOAD_QUEUE);for(let t of e)t.status===d.FAILED&&await m(t.id,{status:d.PENDING,retryCount:0,errorMessage:null});h()}function we(){return b}async function Q(e){E.get(e)?.abort(),E.delete(e)}async function O(){for(let[e,t]of E)t.abort(),E.delete(e)}function me(){ie({pauseAll:O,resumeAll:h})}var d={PENDING:"pending",IN_PROGRESS:"in-progress",PAUSED:"paused",COMPLETE:"complete",EXPIRED:"expired",FAILED:"failed",DEFERRED:"deferred"},j=new Set([d.COMPLETE,d.EXPIRED]);function Ge(e){if(!e||typeof e!="object")throw new Error("Registry entry must be an object.");if(!e.id||typeof e.id!="string")throw new Error('Registry entry must have a string "id".');if(!e.downloadUrl||typeof e.downloadUrl!="string")throw new Error(`Entry "${e.id}" must have a string "downloadUrl".`);if(e.mimeType!==void 0&&e.mimeType!==null&&typeof e.mimeType!="string")throw new Error(`Entry "${e.id}" mimeType must be a string or omitted.`);if(typeof e.version!="number"||!Number.isInteger(e.version)||e.version<0)throw new Error(`Entry "${e.id}" version must be a non-negative integer.`);if(e.ttl!==void 0&&(typeof e.ttl!="number"||e.ttl<0))throw new Error(`Entry "${e.id}" ttl must be a non-negative number (seconds).`)}function Ee(e){return{id:e,status:d.PENDING,data:null,bytesDownloaded:0,totalBytes:null,byteOffset:0,retryCount:0,lastAttemptAt:null,errorMessage:null,deferredReason:null,completedAt:null,expiresAt:null}}function ye(e,t){return t?e+t*1e3:null}function Be(e){return e?Date.now()>=e:!1}async function H(e){try{Ge(e);let t=Date.now(),r=await p(i.REGISTRY,e.id),a=await p(i.DOWNLOAD_QUEUE,e.id),n={id:e.id,downloadUrl:e.downloadUrl,mimeType:e.mimeType??null,version:e.version,protected:e.protected??!1,priority:e.priority??10,ttl:e.ttl??0,totalBytes:e.totalBytes??null,metadata:e.metadata??{},registeredAt:r?.registeredAt??t,updatedAt:t};if(r){if(e.version>r.version){await y(i.REGISTRY,n);let o=a?{...a,status:d.PENDING,bytesDownloaded:0,byteOffset:0,retryCount:0,errorMessage:null,deferredReason:null,completedAt:null,expiresAt:null}:Ee(e.id);await y(i.DOWNLOAD_QUEUE,o),u("registered",{id:e.id,reason:"version-updated"}),h()}return}await y(i.REGISTRY,n),await y(i.DOWNLOAD_QUEUE,Ee(e.id)),u("registered",{id:e.id,reason:"new"}),h()}catch(t){if(t?.name==="QuotaExceededError"){u("error",{id,reason:"insufficient-storage",willRetry:!1});return}else u("error",{id,reason:t?.message??t,willRetry:!1})}}async function De(e){if(!Array.isArray(e))throw new Error("registerFiles expects an array.");let t=new Set(e.map(n=>n.id)),r=await g(i.REGISTRY),a=[];for(let n of r)!t.has(n.id)&&!n.protected&&(await S(i.REGISTRY,n.id),await S(i.DOWNLOAD_QUEUE,n.id),a.push(n.id),u("deleted",{id:n.id,registryRemoved:!0}));for(let n of e)await H(n);return{registered:e.map(n=>n.id),removed:a}}async function Ce(e,t){try{if(e&&t){let r=await p(i.REGISTRY,entry.id);r&&(r.metadata={...r.metadata??{},...t},await y(i.REGISTRY,r))}}catch(r){if(r?.name==="QuotaExceededError"){u("error",{id:e,reason:"insufficient-storage",willRetry:!1});return}else u("error",{id:e,reason:r?.message??r,willRetry:!1})}}async function ge(){let e=await g(i.DOWNLOAD_QUEUE),t=[];for(let r of e)r.status===d.COMPLETE&&Be(r.expiresAt)&&(await y(i.DOWNLOAD_QUEUE,{...r,status:d.EXPIRED}),t.push(r.id),u("expired",{id:r.id}));return t}async function Ae(){let[e,t,r]=await Promise.all([g(i.REGISTRY),g(i.DOWNLOAD_QUEUE),I()]),a=new Map(t.map(o=>[o.id,o]));return{items:e.map(o=>{let s=a.get(o.id)??null;return{id:o.id,downloadUrl:o.downloadUrl,mimeType:o.mimeType,version:o.version,protected:o.protected,priority:o.priority,ttl:o.ttl,totalBytes:o.totalBytes,metadata:o.metadata,registeredAt:o.registeredAt,updatedAt:o.updatedAt,downloadStatus:s?.status??null,bytesDownloaded:s?.bytesDownloaded??0,storedBytes:s?.data?.length??null,progress:s?.totalBytes&&s?.bytesDownloaded?Math.round(s.bytesDownloaded/s.totalBytes*100):null,retryCount:s?.retryCount??0,lastAttemptAt:s?.lastAttemptAt??null,errorMessage:s?.errorMessage??null,deferredReason:s?.deferredReason??null,completedAt:s?.completedAt??null,expiresAt:s?.expiresAt??null}}).sort((o,s)=>o.priority-s.priority),storage:{usageBytes:r.usage,quotaBytes:r.quota,availableBytes:r.available,usageFormatted:M(r.usage),quotaFormatted:M(r.quota),availableFormatted:M(r.available)}}}async function Re(e){let[t,r]=await Promise.all([p(i.REGISTRY,e),p(i.DOWNLOAD_QUEUE,e)]);return t?{id:t.id,downloadUrl:t.downloadUrl,mimeType:t.mimeType??null,version:t.version,protected:t.protected,priority:t.priority,ttl:t.ttl,totalBytes:t.totalBytes,metadata:t.metadata,registeredAt:t.registeredAt,updatedAt:t.updatedAt,downloadStatus:r?.status??null,bytesDownloaded:r?.bytesDownloaded??0,storedBytes:r?.data?.length??null,progress:r?.totalBytes&&r?.bytesDownloaded?Math.round(r.bytesDownloaded/r.totalBytes*100):null,retryCount:r?.retryCount??0,lastAttemptAt:r?.lastAttemptAt??null,errorMessage:r?.errorMessage??null,deferredReason:r?.deferredReason??null,completedAt:r?.completedAt??null,expiresAt:r?.expiresAt??null}:null}async function be(e){let t=await p(i.DOWNLOAD_QUEUE,e);return j.has(t?.status)}async function Qe(e){let t=await p(i.DOWNLOAD_QUEUE,e);t&&await y(i.DOWNLOAD_QUEUE,{...t,status:d.PENDING,data:null,bytesDownloaded:0,byteOffset:0,retryCount:0,errorMessage:null,deferredReason:null,completedAt:null,expiresAt:null})}async function X(e,{removeProtected:t=!1}={}){let r=await p(i.REGISTRY,e);if(!r)throw new Error(`deleteFile: No registered file with id "${e}".`);await Q(e);let a=t||!r.protected;return a?(await S(i.REGISTRY,e),await S(i.DOWNLOAD_QUEUE,e)):await Qe(e),u("deleted",{id:e,registryRemoved:a}),{id:e,registryRemoved:a}}async function Se({removeProtected:e=!1}={}){await O();let t=await N(i.REGISTRY);return Promise.all(t.map(r=>X(r,{removeProtected:e})))}async function Fe(e){let[t,r]=await Promise.all([p(i.REGISTRY,e),p(i.DOWNLOAD_QUEUE,e)]);if(!t)throw new Error(`retrieve: No registered file with id "${e}".`);if(!j.has(r?.status)||!r?.data)throw new Error(`retrieve: File "${e}" has no data yet (status: ${r?.status??"unknown"}).`);return{data:r.data,mimeType:r.mimeType}}var qe={setDBInfo:J,dbGetAllIds:N,registerFile:H,registerFiles:De,startDownloads:fe,stopDownloads:k,retryFailed:pe,isDownloading:we,abortDownload:Q,abortAllDownloads:O,startMonitoring:me,stopMonitoring:$,isOnline:_,isMonitoring:Y,updateConnectivityStatus:se,retrieve:Fe,getAllStatus:Ae,getStatus:Re,isReady:be,delete:X,deleteAll:Se,on:q,off:P,once:ee,getStorageEstimate:I,requestPersistentStorage:re,isPersistentStorage:oe},Dt=qe;export{O as abortAllDownloads,Q as abortDownload,Dt as default,Se as deleteAllFiles,X as deleteFile,u as emit,Ae as getAllStatus,Re as getStatus,I as getStorageEstimate,we as isDownloading,Y as isMonitoring,_ as isOnline,oe as isPersistentStorage,be as isReady,P as off,q as on,ee as once,H as registerFile,De as registerFiles,re as requestPersistentStorage,Fe as retrieve,pe as retryFailed,fe as startDownloads,me as startMonitoring,k as stopDownloads,$ as stopMonitoring,se as updateConnectivityStatus,Ce as updateRegistryMetadata};
